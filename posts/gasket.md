# Drawing Apollonian Gaskets
*December 7, 2024*

An Apollonian gasket is a fractal formed by recursively adding circles
in the gaps between three mutually tangent circles.
It creates patterns of ever smaller circles, producing an interesting fractal structure.

The fractal is generated by the following production rules:

1. Start with three mutually tangent circles.
2. Compute the curvature and position of the next circle that fits into one of the gaps.
3. Repeat the process by forming new sets of three circles from the existing circles and the newly added circle.

We'll implement these rules in python.

First, let’s define what a circle is. A circle is defined by its center point and its curvature. The curvature of a circle is the reciprocal of its radius: positive for outer circles and negative for inner circles. Two circles are considered tangent if they touch at exactly one point. We'll use complex numbers to represent the center of each circle, where the real part represents the x-coordinate and the imaginary part represents the y-coordinate. This simplifies the mathematical equations we'll soon see.
```py
import math, cmath

class Circle:
    def __init__(self, x, y, curvature):
        self.center = complex(x, y)
        self.curvature = curvature
        self.radius = abs(1 / curvature)

    def key(self):
        return f"{int(self.center.real)},{int(self.center.imag)},{int(self.curvature)}"
```

Now let's define an initial set of 3 circles. These circles can be any size
or position as long as they're all touching each other.

```py
# Example circles
c1 = Circle(300, 300, -1/200)  # Outer circle
c2 = Circle(200, 300,  1/100)  # Left inner circle
c3 = Circle(400, 300,  1/100)  # Right inner circle

circles = {c1.key(): c1, c2.key(): c2, c3.key(): c3}
```

We’ve stored our circles in a hashmap for quick lookup. This will help avoid duplicating circles as we generate the fractal.

Before we get into the math, let’s visualize the circles using pygame:

```py
import pygame

pygame.init()
window = pygame.display.set_mode((600, 600))

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    window.fill((255, 255, 255))

    for key in circles:
        circle = circles[key]
        x, y = circle.center.real, circle.center.imag
        pygame.draw.circle(window, (0, 0, 0), (x, y), circle.radius, 1)

    pygame.display.update()
```

At this point, you should see the initial three circles on the screen.

Next, we want to compute the curvature and position of the next circle.
To compute the curvature of a new circle that fits into the gap, we can use Descartes’ Theorem. It states:

$$(\kappa_1 + \kappa_2 + \kappa_3 + \kappa_4)^2 = 2(\kappa_1^2 + \kappa_2^2 + \kappa_3^2 + \kappa_4^2)$$

where $\kappa_1, \kappa_2, \kappa_3, \kappa_4$ are the curvatures of four mutually tangent circles.

Solving for k4​, we get:

$$\kappa_4 = \kappa_1 + \kappa_2 + \kappa_3 \pm 2 \sqrt{\kappa_1 \kappa_2 + \kappa_2 \kappa_3 + \kappa_1 \kappa_3}$$

Implemented here:
```py
def descartes_theorem(k1, k2, k3):
    x = k1 + k2 + k3
    y = 2 * math.sqrt(k1 * k2 + k2 * k3 + k3 * k1)
    return [x + y, x - y]
```

This quadratic equation provides two possible curvatures, corresponding to the two circles that can fit in the gap.

Now that we have the circle's curvature, we can find its position. To find the position of the new circle, we can extend Descartes’ theorem to the complex plane:

$$(\kappa_1 z_1 + \kappa_2 z_2 + \kappa_3 z_3 + \kappa_4 z_4)^2 = 2(\kappa_1^2 + \kappa_2^2 + \kappa_3^2 + \kappa_4^2)$$

where k1, k2, k3, k4 are curvatures and z1, z2, z3, z4 are center points

Solving for z4, we get:

$$z_4 = \frac{z_1 \kappa_1 + z_2 \kappa_2 + z_3 \kappa_3 \pm 2 \sqrt{\kappa_1 \kappa_2 z_1 z_2 + \kappa_2 \kappa_3 z_2 z_3 + \kappa_1 \kappa_3 z_1 z_3}}{\kappa_4}$$

Implemented here:

```py
def complex_descartes_theorem(z1, k1, z2, k2, z3, k3, k4):
    zk1 = z1 * k1
    zk2 = z2 * k2
    zk3 = z3 * k3

    x = zk1 + zk2 + zk3
    y = 2 * cmath.sqrt(zk1 * zk2 + zk2 * zk3 + zk3 * zk1)

    return [(x + y) / k4, (x - y) / k4]
```

To ensure that the new circle positions are valid, we'll need to
check if they're tangent to the existing circles. We'll define a
helper function for this:

```py
def tangential(c1, c2):
    epsilon = 0.1
    r1, r2 = c1.radius, c2.radius
    distance = abs(c1.center - c2.center)
    case1 = abs(distance - (r1 + r2)) < epsilon # c1 and c2 are adjacent
    case2 = abs(distance - abs(r2 - r1)) < epsilon # c2 is inside c1
    return case1 or case2
```

Finally, we can recursively generate the Apollonian gasket:

```py
def find_next_circles(c1, c2, c3):
    k1, k2, k3 = c1.curvature, c2.curvature, c3.curvature
    z1, z2, z3 = c1.center, c2.center, c3.center

    curvatures = descartes_theorem(k1, k2, k3)
    circles = []

    for k in curvatures:
        z4, z5 = complex_descartes_theorem(z1, k1, z2, k2, z3, k3, k)
        circles.append(Circle(z4.real, z4.imag, k))
        circles.append(Circle(z5.real, z5.imag, k))

    return circles

def generate_gasket(c1, c2, c3, depth):
    if depth <= 0:
        return

    next_circles = find_next_circles(c1, c2, c3)

    for c in next_circles:
        mutually_tangential = all(tangential(c, x) for x in [c1, c2, c3])
        if c.radius < 2 or c.key() in circles or not mutually_tangential:
            continue # Skip duplicate or non tangential circles

        circles[c.key()] = c

        # Generate with new sets of 3 circles
        generate_gasket(c1, c2, c, depth - 1)
        generate_gasket(c2, c3, c, depth - 1)
        generate_gasket(c1, c3, c, depth - 1)

generate_gasket(c1, c2, c3, 4)
```

Run the program, and you should see this fractal:

![Generated fractal](gasket.png)

The full source code can be found [here](https://gist.github.com/aabiji/ed3f8d05d03e924db002c6931ad07d72).