<!DOCTYPE html>
<html>
    <head>
        
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>

        
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">

        
        <script type="text/javascript"
            src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>

        <title>  Drawing Apollonian Gaskets </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../assets/styles.css">
    </head>

    <body>
        <div class="left">
            <a href="https://aabiji.github.io" class="img-container">
                <img alt="profile-pic" src="https://images.unsplash.com/photo-1722111193515-2a086f37f028?q=80&w=1470&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D">
                <div class="text-overlay">Abigail A.</div>
            </a>
            <a href="https://github.com/aabiji">Github</a>
        </div>

        <div class="right">
            <div class="content"><h1>Drawing Apollonian Gaskets</h1>

<p><em>December 7, 2024</em></p>

<p>An Apollonian gasket is a fractal formed by recursively adding circles
in the gaps between three mutually tangent circles.
It creates patterns of ever smaller circles, producing an interesting fractal structure.</p>

<p>The fractal is generated by the following production rules:</p>

<ol>
<li>Start with three mutually tangent circles.</li>
<li>Compute the curvature and position of the next circle that fits into one of the gaps.</li>
<li>Repeat the process by forming new sets of three circles from the existing circles and the newly added circle.</li>
</ol>

<p>We&rsquo;ll implement these rules in python.</p>

<p>First, let’s define what a circle is. A circle is defined by its center point and its curvature. The curvature of a circle is the reciprocal of its radius: positive for outer circles and negative for inner circles. Two circles are considered tangent if they touch at exactly one point. We&rsquo;ll use complex numbers to represent the center of each circle, where the real part represents the x-coordinate and the imaginary part represents the y-coordinate. This simplifies the mathematical equations we&rsquo;ll soon see.</p>

<pre><code class="language-py">import math, cmath

class Circle:
    def __init__(self, x, y, curvature):
        self.center = complex(x, y)
        self.curvature = curvature
        self.radius = abs(1 / curvature)

    def key(self):
        return f&quot;{int(self.center.real)},{int(self.center.imag)},{int(self.curvature)}&quot;
</code></pre>

<p>Now let&rsquo;s define an initial set of 3 circles. These circles can be any size
or position as long as they&rsquo;re all touching each other.</p>

<pre><code class="language-py"># Example circles
c1 = Circle(300, 300, -1/200)  # Outer circle
c2 = Circle(200, 300,  1/100)  # Left inner circle
c3 = Circle(400, 300,  1/100)  # Right inner circle

circles = {c1.key(): c1, c2.key(): c2, c3.key(): c3}
</code></pre>

<p>We’ve stored our circles in a hashmap for quick lookup. This will help avoid duplicating circles as we generate the fractal.</p>

<p>Before we get into the math, let’s visualize the circles using pygame:</p>

<pre><code class="language-py">import pygame

pygame.init()
window = pygame.display.set_mode((600, 600))

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    window.fill((255, 255, 255))

    for key in circles:
        circle = circles[key]
        x, y = circle.center.real, circle.center.imag
        pygame.draw.circle(window, (0, 0, 0), (x, y), circle.radius, 1)

    pygame.display.update()
</code></pre>

<p>At this point, you should see the initial three circles on the screen.</p>

<p>Next, we want to compute the curvature and position of the next circle.
To compute the curvature of a new circle that fits into the gap, we can use Descartes’ Theorem. It states:</p>
<p><span class="math display">\[(\kappa_1 + \kappa_2 + \kappa_3 + \kappa_4)^2 = 2(\kappa_1^2 + \kappa_2^2 + \kappa_3^2 + \kappa_4^2)\]</span></p><p>where <span class="math inline">\(\kappa_1, \kappa_2, \kappa_3, \kappa_4\)</span> are the curvatures of four mutually tangent circles.</p>

<p>Solving for k4​, we get:</p>
<p><span class="math display">\[\kappa_4 = \kappa_1 + \kappa_2 + \kappa_3 \pm 2 \sqrt{\kappa_1 \kappa_2 + \kappa_2 \kappa_3 + \kappa_1 \kappa_3}\]</span></p><p>Implemented here:</p>

<pre><code class="language-py">def descartes_theorem(k1, k2, k3):
    x = k1 + k2 + k3
    y = 2 * math.sqrt(k1 * k2 + k2 * k3 + k3 * k1)
    return [x + y, x - y]
</code></pre>

<p>This quadratic equation provides two possible curvatures, corresponding to the two circles that can fit in the gap.</p>

<p>Now that we have the circle&rsquo;s curvature, we can find its position. To find the position of the new circle, we can extend Descartes’ theorem to the complex plane:</p>
<p><span class="math display">\[(\kappa_1 z_1 + \kappa_2 z_2 + \kappa_3 z_3 + \kappa_4 z_4)^2 = 2(\kappa_1^2 + \kappa_2^2 + \kappa_3^2 + \kappa_4^2)\]</span></p><p>where k1, k2, k3, k4 are curvatures and z1, z2, z3, z4 are center points</p>

<p>Solving for z4, we get:</p>
<p><span class="math display">\[z_4 = \frac{z_1 \kappa_1 + z_2 \kappa_2 + z_3 \kappa_3 \pm 2 \sqrt{\kappa_1 \kappa_2 z_1 z_2 + \kappa_2 \kappa_3 z_2 z_3 + \kappa_1 \kappa_3 z_1 z_3}}{\kappa_4}\]</span></p><p>Implemented here:</p>

<pre><code class="language-py">def complex_descartes_theorem(z1, k1, z2, k2, z3, k3, k4):
    zk1 = z1 * k1
    zk2 = z2 * k2
    zk3 = z3 * k3

    x = zk1 + zk2 + zk3
    y = 2 * cmath.sqrt(zk1 * zk2 + zk2 * zk3 + zk3 * zk1)

    return [(x + y) / k4, (x - y) / k4]
</code></pre>

<p>To ensure that the new circle positions are valid, we&rsquo;ll need to
check if they&rsquo;re tangent to the existing circles. We&rsquo;ll define a
helper function for this:</p>

<pre><code class="language-py">def tangential(c1, c2):
    epsilon = 0.1
    r1, r2 = c1.radius, c2.radius
    distance = abs(c1.center - c2.center)
    case1 = abs(distance - (r1 + r2)) &lt; epsilon # c1 and c2 are adjacent
    case2 = abs(distance - abs(r2 - r1)) &lt; epsilon # c2 is inside c1
    return case1 or case2
</code></pre>

<p>Finally, we can recursively generate the Apollonian gasket:</p>

<pre><code class="language-py">def find_next_circles(c1, c2, c3):
    k1, k2, k3 = c1.curvature, c2.curvature, c3.curvature
    z1, z2, z3 = c1.center, c2.center, c3.center

    curvatures = descartes_theorem(k1, k2, k3)
    circles = []

    for k in curvatures:
        z4, z5 = complex_descartes_theorem(z1, k1, z2, k2, z3, k3, k)
        circles.append(Circle(z4.real, z4.imag, k))
        circles.append(Circle(z5.real, z5.imag, k))

    return circles

def generate_gasket(c1, c2, c3, depth):
    if depth &lt;= 0:
        return

    next_circles = find_next_circles(c1, c2, c3)

    for c in next_circles:
        mutually_tangential = all(tangential(c, x) for x in [c1, c2, c3])
        if c.radius &lt; 2 or c.key() in circles or not mutually_tangential:
            continue # Skip duplicate or non tangential circles

        circles[c.key()] = c

        # Generate with new sets of 3 circles
        generate_gasket(c1, c2, c, depth - 1)
        generate_gasket(c2, c3, c, depth - 1)
        generate_gasket(c1, c3, c, depth - 1)

generate_gasket(c1, c2, c3, 4)
</code></pre>

<p>Run the program, and you should see this fractal:</p>

<p><img src="assets/gasket.png" alt="Generated fractal" /></p>

<p>The full source code can be found <a href="https://gist.github.com/aabiji/ed3f8d05d03e924db002c6931ad07d72">here</a>.</p>
</div>
        </div>
    </body>
</html>